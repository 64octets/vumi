# -*- coding: utf-8 -*-
# -*- test-case-name: vumi.transports.truteq.tests.test_truteq -*-

"""TruTeq USSD transport."""

from twisted.python import log
from twisted.internet.defer import inlineCallbacks, Deferred
from twisted.internet import reactor

from ssmi import client

from vumi.utils import normalize_msisdn
from vumi.message import TransportUserMessage
from vumi.transports.base import Transport


class VumiSSMIProtocol(client.SSMIClient):
    """
    Subclassing the protocol to avoid me having to
    work with callbacks to do authorization
    """
    def __init__(self, username, password):
        self._username = username  # these could probably be a
        self._password = password  # callback instance var

    def set_handler(self, handler):
        # set the variables needed by SSMIClient so I don't have to
        # specify callbacks manually for each function
        self.handler = handler
        self._ussd_callback = self.handler.ussd_callback
        self._sms_callback = self.handler.sms_callback
        self._errback = self.handler.errback
        # ugh, can't do normal super() call because twisted's protocol.Factory
        # is an old style class that doesn't subclass object.
        client.SSMIClient.__init__(self)

    def connectionMade(self, *args, **kwargs):
        client.SSMIClient.connectionMade(self, *args, **kwargs)
        self.factory.onConnectionMade.callback(self)

    def connectionLost(self, *args, **kwargs):
        client.SSMIClient.connectionLost(self, *args, **kwargs)
        self.factory.onConnectionLost.callback(self)


class VumiSSMIFactory(client.SSMIFactory):
    """
    Subclassed the factory to allow me to work with my custom subclassed
    protocol
    """
    protocol = VumiSSMIProtocol

    def __init__(self, *args, **kwargs):
        self.args = args
        self.kwargs = kwargs
        self.onConnectionMade = Deferred()
        self.onConnectionLost = Deferred()

    def buildProtocol(self, addr):
        prot = self.protocol(*self.args, **self.kwargs)
        prot.factory = self
        log.msg('SSMIFactory Connected.')
        log.msg('SSMIFactory Resetting reconnection delay')
        self.resetDelay()
        return prot


class TruteqTransport(Transport):
    """
    The USSDTransport for TruTeq
    """

    VUMI_TO_SSMI_EVENT = {
        TransportUserMessage.SESSION_NEW: client.SSMI_USSD_TYPE_NEW,
        TransportUserMessage.SESSION_RESUME: client.SSMI_USSD_TYPE_EXISTING,
        TransportUserMessage.SESSION_CLOSE: client.SSMI_USSD_TYPE_END,
        }

    SSMI_TO_VUMI_EVENT = dict((v, k) for k, v in VUMI_TO_SSMI_EVENT.items())
    SSMI_TO_VUMI_EVENT[client.SSMI_USSD_TYPE_TIMEOUT] = \
            TransportUserMessage.SESSION_CLOSE

    def validate_config(self):
        """
        Transport-specific config validation happens in here.
        """
        self.username = self.config['username']
        self.password = self.config['password']
        self.host = self.config['host']
        self.port = int(self.config['port'])
        self.transport_type = self.config.get('transport_type', 'ussd')

    def setup_transport(self):
        # FIXME:    this needs to be done more intelligently, it stores which
        #           MSISDN dialed into which ussd code, problem is that it is
        #           memory and will be lost during restarts.
        self.storage = {}

        # start the USSD transport
        factory = VumiSSMIFactory(self.username, self.password)
        factory.onConnectionMade.addCallback(self.ssmi_connected)
        # TODO: this needs to yield until the connection is made so
        # that messages can be processed as soon as setup_transport
        # exits.
        self.ssmi_connector = reactor.connectTCP(self.host, self.port, factory)

    def teardown_transport(self):
        self.ssmi_connector.disconnect()

    @inlineCallbacks
    def ssmi_connected(self, client):
        log.msg("SSMI Connected, adding handlers")
        self.ssmi_client = client
        # link self.ussd_callback, self.sms_callback and self.errback as
        # callbacks for events generated by the SSMI protocol
        self.ssmi_client.set_handler(self)

    def ussd_callback(self, msisdn, ussd_type, phase, message):
        log.msg("Received USSD, from: %s, message: %s" % (msisdn, message))
        session_event = self.SSMI_TO_VUMI_EVENT[ussd_type]

        # FIXME: See the note about self.storage
        # If it's a new session then store the message as the USSD code
        # use that as the routing key for publishing.
        if session_event == TransportUserMessage.SESSION_NEW:
            # cache
            ussd_code = self.storage[msisdn] = message
            text = None

        # If its the end of a session or a session has timed-out then we
        # should remove the USSD code from the storage
        elif session_event == TransportUserMessage.SESSION_CLOSE:
            # clear cache
            ussd_code = self.storage.get(msisdn)
            if msisdn in self.storage:
                del self.storage[msisdn]
            text = message

        # if it's an existing session then look up the USSD code from
        # the storage and use that as the routing key
        elif session_event == TransportUserMessage.SESSION_RESUME:
            # read cache
            ussd_code = self.storage.get(msisdn)
            text = message

        self.publish_message(
            from_addr=normalize_msisdn(msisdn),
            to_addr=normalize_msisdn(ussd_code),
            session_event=session_event,
            # TODO: does content need to be decoded?
            content=text,
            transport_name=self.transport_name,
            transport_type=self.transport_type,
            transport_metadata={},
            )

    def sms_callback(self, *args, **kwargs):
        log.err("Got SMS from SSMI but SMSes not supported: %r, %r"
                % (args, kwargs))

    def errback(self, *args, **kwargs):
        log.err("Got error from SSMI: %r, %r" % (args, kwargs))

    @inlineCallbacks
    def handle_outbound_message(self, message):
        text = message['content']
        if text is None:
            text = ''
        ssmi_session_type = self.VUMI_TO_SSMI_EVENT[message['session_event']]
        self.ssmi_client.send_ussd(message['to_addr'], text, ssmi_session_type)
