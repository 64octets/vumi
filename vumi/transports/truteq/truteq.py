# -*- coding: utf-8 -*-
# -*- test-case-name: vumi.transports.truteq.tests.test_truteq -*-

"""TruTeq transport."""

from twisted.python import log
from twisted.internet.defer import inlineCallbacks, Deferred

from ssmi import client

from vumi.transports.base import Transport
from vumi.transports.failures import PermanentFailure


def ussd_code_to_routing_key(ussd_code):
    # convert *120*663*79# to s120s663s79h since
    # * and # are wildcards for AMQP based routing
    ussd_code = ussd_code.replace("*", "s")
    ussd_code = ussd_code.replace("#", "h")
    return ussd_code


class SessionType(object):
    """ussd_type's from SSMI documentation"""
    NEW = client.SSMI_USSD_TYPE_NEW
    EXISTING = client.SSMI_USSD_TYPE_EXISTING
    END = client.SSMI_USSD_TYPE_END
    TIMEOUT = client.SSMI_USSD_TYPE_TIMEOUT


class VumiSSMIProtocol(client.SSMIClient):
    """
    Subclassing the protocol to avoid me having to
    work with callbacks to do authorization
    """
    def __init__(self, username, password):
        self._username = username  # these could probably be a
        self._password = password  # callback instance var

    def set_handler(self, handler):
        # set the variables needed by SSMIClient so I don't have to
        # specify callbacks manually for each function
        self.handler = handler
        self._ussd_callback = self.handler.ussd_callback
        self._sms_callback = self.handler.sms_callback
        self._errback = self.handler.errback
        # ugh, can't do normal super() call because twisted's protocol.Factory
        # is an old style class that doesn't subclass object.
        client.SSMIClient.__init__(self)

    def connectionMade(self, *args, **kwargs):
        client.SSMIClient.connectionMade(self, *args, **kwargs)
        self.factory.onConnectionMade.callback(self)

    def connectionLost(self, *args, **kwargs):
        client.SSMIClient.connectionLost(self, *args, **kwargs)
        self.factory.onConnectionLost.callback(self)


class VumiSSMIFactory(client.SSMIFactory):
    """
    Subclassed the factory to allow me to work with my custom subclassed
    protocol
    """
    protocol = VumiSSMIProtocol

    def __init__(self, *args, **kwargs):
        self.args = args
        self.kwargs = kwargs
        self.onConnectionMade = Deferred()
        self.onConnectionLost = Deferred()

    def buildProtocol(self, addr):
        prot = self.protocol(*self.args, **self.kwargs)
        prot.factory = self
        log.msg('SSMIFactory Connected.', logLevel=logging.DEBUG)
        log.msg('SSMIFactory Resetting reconnection delay',
                logLevel=logging.DEBUG)
        self.resetDelay()
        return prot


class TruteqTransport(Transport):
    """
    The USSDTransport for TruTeq
    """

    def startWorker(self):
        log.msg("Starting the USSDTransport")

        username = self.config.pop('username')
        password = self.config.pop('password')
        host = self.config.pop("host")
        port = self.config.pop("port")

        # FIXME:    this needs to be done more intelligently, it stores which
        #           MSISDN dialed into which ussd code, problem is that it is
        #           memory and will be lost during restarts.
        self.storage = {}

        # start the USSD transport
        factory = VumiSSMIFactory(username, password)
        factory.onConnectionMade.addCallback(self.ssmi_connected)
        reactor.connectTCP(host, port, factory)

    @inlineCallbacks
    def ssmi_connected(self, client):
        log.msg("SSMI Connected, adding handlers")
        self.ssmi_client = client
        # link self.ussd_callback, self.sms_callback and self.errback as
        # callbacks for events generated by the SSMI protocol
        self.ssmi_client.set_handler(self)

        # Start the publisher
        self.publisher = yield self.start_publisher(TruTeqPublisher)
        # Start the consumer, pass along the send_ussd callback for sending
        # back consumed AMQP messages over TruTeq.
        self.consumer = yield self.start_consumer(TruTeqConsumer,
                                                  self.send_ussd)

    def ussd_callback(self, msisdn, ussd_type, phase, message):
        print "Received USSD, from: %s, message: %s" % (msisdn, message)

        # FIXME: See the note about self.storage
        # If it's a new session then store the message as the USSD code
        # use that as the routing key for publishing.
        if ussd_type == SessionType.NEW:
            # cache
            ussd_code = self.storage[msisdn] = message
            options = {
                'routing_key': ussd_code_to_routing_key('ussd.%s' % ussd_code),
            }

        # If its the end of a session or a session has timed-out then we
        # should remove the USSD code from the storage
        elif ussd_type in [SessionType.END, SessionType.TIMEOUT]:
            # clear cache
            if msisdn in self.storage:
                del self.storage[msisdn]
            options = {}

        # if it's an existing session then look up the USSD code from
        # the storage and use that as the routing key
        elif ussd_type == SessionType.EXISTING:
            # read cache
            ussd_code = self.storage.get(msisdn)
            options = {
                'routing_key': ussd_code_to_routing_key('ussd.%s' % ussd_code),
            }

        self.publisher.publish_message(Message(**{
            'msisdn': msisdn,
            'ussd_type': ussd_type,
            'phase': phase,
            'message': message,
        }), **options)

    def send_ussd(self, msisdn, ussd_type, message):
        print "Sending USSD, to: %s, message: %s" % (msisdn, message)
        self.ssmi_client.send_ussd(str(msisdn), str(message), str(ussd_type))

    def sms_callback(self, *args, **kwargs):
        print "Got SMS:", args, kwargs

    def errback(self, *args, **kwargs):
        print "Got Error: ", args, kwargs

    def stopWorker(self):
        log.msg("Stopping the USSDTransport")
